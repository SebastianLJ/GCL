// Open the file that defines the type "expr" we shall use as AST
%{
open CalculatorTypesAST
%}

// Declare the tokens (terminal symbols)
%token <int> NUM
%token <String> x
%token <bool> boolean
%token ASSIGN SEPERATOR IF FI DO OD FUNC CONC 
%token PLUS MINUS TIMES DIV POW  LPAR RPAR
%token AND OR ANDH ORH NOT EQUAL NEQUAL GT GTE LT LTE
%token EOF
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)
%right POW
%left TIMES DIV
%left PLUS MINUS

%left AND ANDH
%left OR ORH


// We declare the initial non-terminal symbol
%start start

// We specify the return type of each of then non-terminal symbols
%type <C> start
%type <C> cExpr
%type <GC> gcExpr
%type <a> aExpr
%type <b> bExpr

// Grammar productions
%%

// The first production in "formal" notation is
// start -> expression
// here written:
start: cExpr EOF             { $1 }

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:

cExpr:
  | aExpr ASSIGN aExpr                  { AssignExpr($1, $3) }
  | cExpr SEPERATOR cExpr               { SeperatorExpr($1, $3) }
  | IF WHITESPACE gcExpr WHITESPACE FI  { IfExpr($3) }
  | DO WHITESPACE gcExpr WHITESPACE OD  { DoExpr($3) }

gcExpr:
  | bExpr FUNC cExpr    { FuncExpr($1, $3) }
  | GC CONC GC          { ConcExpr($1, $3) }

aExpr:
  | aExpr PLUS aExpr    { PlusExpr($1,$3) }
  | aExpr MINUS aExpr   { MinusExpr($1,$3) }
  | aExpr TIMES aExpr   { TimesExpr($1,$3) }
  | aExpr DIV aExpr     { DivExpr($1,$3) }
  | aExpr POW aExpr     { PowExpr($1,$3) }
  | MINUS aExpr         { UMinusExpr($2) }
  | NUM                 { Num($1) }
  | LPAR aExpr RPAR     { $2 }

bExpr:
  | bExpr AND bExpr     { AndExpr($1, $3) }
  | bExpr OR bExpr      { OrExpr($1, $3) }
  | bExpr ANDH bExpr    { AndhExpr($1, $3) }
  | bExpr ORH bExpr     { OrhExpr($1, $3) }
  | NOT bExpr           { NotExpr($2) }
  | bExpr EQUAL bExpr   { EqualExpr($1, $3) }
  | bExpr NEQUAL bExpr  { NequalExpr($1, $3) }
  | bExpr GT bExpr      { GtExpr($1, $3) }
  | bExpr GTE bExpr     { GteExpr($1, $3) }
  | bExpr LT bExpr      { LtExpr($1, $3) }
  | bExpr LTE bExpr     { LteExpr($1, $3) }

// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
