// Open the file that defines the type "expr" we shall use as AST
%{
open InputTypesAST
%}

// Declare the tokens (terminal symbols)
%token <int> NUM
%token <string> VAR
%token <char> ARRAY
%token SEPARATOR
%token LBRACK RBRACK 
%token ASSIGN
%token <char> SIGN
%token ZERO PLUS MINUS 
%token LCBRACK RCBRACK
%token EOF WHITESPACE
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)
%right SEPARATOR


// We declare the initial non-terminal symbol
%start start

// We specify the return type of each of then non-terminal symbols
%type <signInit> start
%type <init> iExpr
%type <arr> arrElem
%type <signInit> signExpr
%type <signArr> signArrElem

// Grammar productions
%%

// The first production in "formal" notation is
// start -> expression
// here written:
start: signExpr EOF             { $1 }

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:

iExpr:
  | VAR ASSIGN NUM                           { VarInit($1, $3)           }
  | ARRAY ASSIGN LBRACK arrElem RBRACK       { ArrInit($1, $4)           }
  | iExpr SEPARATOR iExpr                    { SeqInit($1, $3)           }
arrElem:
  | NUM                                      { NumElem($1)     }
  | NUM SEPARATOR arrElem                    { Elems($1, $3)   }
signExpr:
  | VAR ASSIGN SIGN                      { SignVarInit($1, $3)       }
  | ARRAY ASSIGN LCBRACK signArrElem RCBRACK     { SignArrInit($1, $4)       }
signArrElem:  
  | SIGN                                     { SignElem($1)         }
  | SIGN SEPARATOR signArrElem           { SignArrElems($1, $3)  }

//  | PLUS                                       { Sign($1)                  }
 // | MINUS                                      { Sign($1)                  }
 // | ZERO                                       { Sign($1)                  }
// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
